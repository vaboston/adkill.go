//inspired by this script https://raw.githubusercontent.com/penthium2/adkill/master/adkill.sh
package main

import (
  "fmt"
	"os"
  "io"
  "net/http"
  "io/ioutil"
  "log"
  "strings"
  "unicode"
)
var header = "# Generated by adkill.sh"

// Prod : /etc/hosts pour mac et linux
var pathHosts = "/etc/hosts"
var dirCopy = "public/.hosts-system/"

// var pathFleHosts = "public/hosts"
var fileTemp string = "public/fileTemp"
// var pathOldFileHosts = ".adkill/hosts-system"
var ats, emd, exp, fsa, grm, hfs, hjk, mmt, pha, psh, wrz int = 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

func help(){
  fmt.Println( "syntax error")
  fmt.Println( "run adkill.sh <option>")
  fmt.Println( "ats : activate blacklist of ad/tracking servers listed in the hpHosts database.")
  fmt.Println( "emd : activate blacklist of malware sites listed in the hpHosts database.")
  fmt.Println( "exp : activate blacklist of exploit sites listed in the hpHosts database.")
  fmt.Println( "fsa : activate blacklist of fraud sites listed in the hpHosts database.")
  fmt.Println( "grm : activate blacklist of sites involved in spam (that do not otherwise meet any other classification criteria) listed in the hpHosts database.")
  fmt.Println( "hfs : activate blacklist of sites spamming the hpHosts forums (and not meeting any other classification criteria) listed in the hpHosts database.")
  fmt.Println( "hjk : activate blacklist of hijack sites listed in the hpHosts database.")
  fmt.Println( "mmt : activate blacklist of sites involved in misleading marketing (e.g. fake Flash update adverts) listed in the hpHosts database.")
  fmt.Println( "pha : activate blacklist of illegal pharmacy sites listed in the hpHosts database.")
  fmt.Println( "psh : activate blacklist of phishing sites listed in the hpHosts database.")
  fmt.Println( "wrz : activate blacklist of warez/piracy sites listed in the hpHosts database.")
  fmt.Println( "all : activate blacklist of all sites listed in the hpHosts database.")
}
func remD(elements []string) []string {
    // This function remove duplicate lines in a array of string
    encountered := map[string]bool{}
    result := []string{}

    for v := range elements {
        if encountered[elements[v]] == true {
            // Do not add duplicate.
        } else {
            // Record this element as an encountered element.
            encountered[elements[v]] = true
            // Append to result slice.
            result = append(result, elements[v])
        }
    }
    // Return the new slice.
    return result
}

func remComL(pathFile string){
  // This function remove commented lines
  input, err := ioutil.ReadFile(pathFile)
  if err != nil {
          log.Fatalln(err)
  }
  lines := strings.Split(string(input), "\n")
  var f []string
    for _, str := range lines {
        if strings.HasPrefix(str, "#") == false {
            f = append(f, str)
        }
    }
    output := strings.Join(f, "\n")
    err = ioutil.WriteFile(pathFile, []byte(output), 0644)
    if err != nil {
            log.Fatalln(err)
    }

}
func check(err error) {
  // Thos funtion check the errors
    if err != nil {
        fmt.Println("Error : %s", err.Error())
        os.Exit(1)
    }
}
// func copyFile(pathSrc, pathDst string){
//   srcFile, err := os.Open(pathSrc)
//     check(err)
//     defer srcFile.Close()
//
//     destFile, err := os.Create(pathDst) // creates if file doesn't exist
//     check(err)
//     defer destFile.Close()
//
//     _, err = io.Copy(destFile, srcFile) // check first var for number of bytes copied
//     check(err)
// }
func download_and_copy(url string, pathFile string) {

  resp, err := http.Get(url)
  if err != nil {
      // handle error
  }
  defer resp.Body.Close()

  defer resp.Body.Close()
  body, err := ioutil.ReadAll(resp.Body)
  file, err := os.OpenFile(pathFile, os.O_APPEND|os.O_WRONLY,0600)
  if err != nil {
      panic(err)
  }
  defer file.Close()

  if _, err = file.WriteString(string(body)); err != nil {
   panic(err)
  }
}
func usineAGaz(pathHosts, pathDownload string ) {
  // This function check il adkill is already passed here, then he parse, clean, wash e new hosts file
  fileHosts, err := ioutil.ReadFile(pathHosts)
  if err != nil {
          log.Fatalln(err)
  }
  fileDownload, err := ioutil.ReadFile(pathDownload)
  if err != nil {
          log.Fatalln(err)
  }

  // Si il n'y a pas de # Generated By je sauvegarde tous le fichier
  linesDownload := strings.Split(string(fileDownload), "\n")
  // linesDownload = remD(linesDownload)
  linesHosts := strings.Split(string(fileHosts), "\n")
  alreadyKill := false
  var dontAdd []string
  // If we find header, adkill is already passed here
  for _, check := range linesHosts {
      if check == header {
        alreadyKill = true
      }
  }
  f := func(c rune) bool {
        return  unicode.IsSpace(c)
  }
  if alreadyKill == false {
    // First passage
    fmt.Println("=========First passage of adkill=============")
    var oldHosts []string
    for _, str := range linesHosts {
      r := strings.FieldsFunc(str, f)
      if str ==  header{
        break
      }
      if len(r) == 2 {
        dontAdd = append(dontAdd, string(r[1]))
      }
      oldHosts = append(oldHosts, str)
    }
    fmt.Println("Old hosts : ")
    for index := 0;  index< len(oldHosts); index++ {
      fmt.Println(oldHosts[index])
    }
    var result []string
    f := func(c rune) bool {
          return  unicode.IsSpace(c)
    }
    for index := 0;  index< len(oldHosts); index++ {
      result = append(result, oldHosts[index])
    }
    result = append(result, header)
    fmt.Println("taille du tableau linesdownload : ")
    fmt.Println(len(linesDownload))
    fmt.Println("taille du tableau doNatAdd : ")
    fmt.Println(len(dontAdd))
    // var newCont []string
    fmt.Println("Adding downloaded content : ")
    for index := 0;  index< len(linesDownload); index++ {
      r := strings.FieldsFunc(linesDownload[index], f)
      if len(r) == 2 {

        for i := 0;  i< len(dontAdd); i++{
          q := strings.FieldsFunc(dontAdd[i], f)
          if r[1] != q[0] {
          result = append(result, "127.0.0.1 " + r[1])
          }
        }
      }
    }
      output := strings.Join(result, "\n")
      err = ioutil.WriteFile(pathHosts, []byte(output), 0644)
      if err != nil {
              log.Fatalln(err)
      }
  } else {
    fmt.Println("Second passage of adkill")
    // Second passage
    // we put old header in a head array
    var dontAdd []string
    var head []string
    var stop = false
    f := func(c rune) bool {
          return  unicode.IsSpace(c)
    }
    for _, check := range linesHosts {
      r := strings.FieldsFunc(check, f)
      if len(r) > 0 {
        if check == header {
          break
          stop = true
        }
        if stop == false && len(r) == 2{
          head = append(head, string(r[0] + " " + r[1]))
          dontAdd = append(dontAdd, string(r[1]))
        }
      }
    }

    // we put commented line in unbanned array
    var unbaned []string
    for index := 0;  index< len(linesHosts); index++ {
      fmt.Println(index)
      r := strings.FieldsFunc(linesHosts[index], f)
      if strings.HasPrefix(linesHosts[index], "#") == true && linesHosts[index] != header{
        if len(r) == 2 {
          if string(r[0]) == header{
            break
          }
          unbaned = append(unbaned, string(r[0] + " " + r[1]))
          dontAdd = append(dontAdd, string(r[1]))
        }
      }
    }

    var newCont []string

    fmt.Println("Adding content ")
    fmt.Println("taille de linesFownlaod")
    fmt.Println(len(linesDownload))
    fmt.Println("taille de dontAdd")
    fmt.Println(len(dontAdd))
    // we check il adding line is not in unbaned array



    for index := 0;  index< len(linesDownload); index++ {
      r := strings.FieldsFunc(linesDownload[index], f)
      // fmt.Println(index)
      if len(r) == 2 {
        flag := true
        for i := 0;  i< len(dontAdd); i++ {
          q := strings.FieldsFunc(dontAdd[i], f)
          if  len(q) == 1 {
            if r[1] == q[0] {
              flag = false
            }
          }
        }
        if flag == true {
          newCont = append(newCont, "127.0.0.1 " + r[1])
        }
      }

    }
    // We parse all
    var result []string
    fmt.Println("========== Head ===========")

    for index := 0;  index< len(head); index++ {
      fmt.Println(head[index])
      head[index] = strings.Replace(head[index], "    ", " ", -1)
      result = append(result, head[index])
    }
    fmt.Println("========== Unbaned ===========")
    for index := 0;  index< len(unbaned); index++ {
      unbaned[index] = strings.Replace(unbaned[index], "    ", " ", -1)
      fmt.Println(unbaned[index])
      result = append(result, unbaned[index])
    }
    // fmt.Println("========== DONTADD ===========")
    //
    // for index := 0;  index< len(dontAdd); index++ {
    //   fmt.Println(dontAdd[index])
    //
    // }

    result = append(result, header)


    // fmt.Println("========== FIRST 1O LIGNE ADD ===========")
    // for index := 0;  index< 10; index++ {
    //   fmt.Println(newCont[index])
    // }
    for index := 0;  index< len(newCont); index++ {
      result = append(result, newCont[index])

    }


    fmt.Println("Writing in a file...")

    result = remD(result)

    output := strings.Join(result, "\n")
      err = ioutil.WriteFile(pathHosts, []byte(output), 0644)
      if err != nil {
              log.Fatalln(err)
      }
  }
}

func main() {

  if len(os.Args) > 1 {
    arg := os.Args[1]

    if len(arg) != 3 {
      help()
    } else {
      switch arg {
        case "ats":
          ats=1
        case "emd":
          emd=1
        case "exp":
          exp=1
        case "fsa":
          fsa=1
        case "grm":
          grm=1
        case "hfs":
          hfs=1
        case "hjk":
          hjk=1
        case "mmt":
          mmt=1
        case "pha":
          pha=1
        case "psh":
          psh=1
        case "wrz":
          wrz=1
        case "all":
          ats=1
          emd=1
          exp=1
          fsa=1
          grm=1
          hfs=1
          hjk=1
          mmt=1
          pha=1
          psh=1
          wrz=1
        default:
          help()
        }
      }
      // fmt.Println(ats)
      // fmt.Println(emd)
      // fmt.Println(exp)
      // fmt.Println(fsa)
      // fmt.Println(grm)
      // fmt.Println(hfs)
      // fmt.Println(hjk)
      // fmt.Println(mmt)
      // fmt.Println(pha)
      // fmt.Println(psh)
      // fmt.Println(wrz)

      if len(arg) == 3 {


          pathCopy := dirCopy + "hosts"
          os.MkdirAll(dirCopy, os.ModePerm)

        // we save old hosts
        r, err := os.Open(pathHosts)
        if err != nil {
            panic(err)
        }
        defer r.Close()

        w, err := os.Create(pathCopy)
        if err != nil {
            panic(err)
        }
        defer w.Close()

        n, err := io.Copy(w, r)
        if err != nil {
            panic(err)
        }

       fmt.Printf("Copied %v bytes\n", n)

       if _, err := os.Stat("fileTemp"); os.IsNotExist(err) {
         os.Create(fileTemp)
       }

      fmt.Println("Downloading ad-blocking hosts files...")
      fmt.Println("Downloading from : winhelp2002.mvps.org :")
      download_and_copy("http://winhelp2002.mvps.org/hosts.txt",fileTemp)
      if ats==1 {
        download_and_copy("http://hosts-file.net/ad_servers.txt",fileTemp)
        fmt.Println("Downloading from hosts-file.net : ad/tracking servers")
      }
      if emd==1 {
        download_and_copy("http://hosts-file.net/emd.txt",fileTemp)
        fmt.Println("Downloading from hosts-file.net : malware sites")

      }
      if exp==1 {
        download_and_copy("http://hosts-file.net/exp.txt",fileTemp)
        fmt.Println("Downloading from hosts-file.net : exploit sites")

      }
      if fsa==1 {
        download_and_copy("http://hosts-file.net/fsa.txt",fileTemp)
        fmt.Println("Downloading from hosts-file.net : fraud sites")

      }
      if grm==1 {
        download_and_copy("http://hosts-file.net/grm.txt",fileTemp)
        fmt.Println("Downloading from hosts-file.net : sites involved in spam")

      }
      if hfs==1 {
        download_and_copy("http://hosts-file.net/hfs.txt",fileTemp)
        fmt.Println("Downloading from hosts-file.net : sites spamming the hpHosts forums")

      }
      if hjk==1 {
        download_and_copy("http://hosts-file.net/hjk.txt",fileTemp)
        fmt.Println("Downloading from hosts-file.net : hijack sites")

      }
      if mmt==1 {
        download_and_copy("http://hosts-file.net/mmt.txt",fileTemp)
        fmt.Println("Downloading from hosts-file.net : sites involved in misleading marketing")

      }
      if pha==1 {
        download_and_copy("http://hosts-file.net/pha.txt",fileTemp)
        fmt.Println("Downloading from hosts-file.net : illegal pharmacy sites")

      }
      if psh==1 {
        download_and_copy("http://hosts-file.net/psh.txt",fileTemp)
        fmt.Println("Downloading from hosts-file.net : phishing sites")

      }
      if wrz==1 {
        download_and_copy("http://hosts-file.net/wrz.txt",fileTemp)
        fmt.Println("Downloading from hosts-file.net : warez/piracy")

      }
      fmt.Println("Downloading from someonewhocares.org :")
      download_and_copy("http://someonewhocares.org/hosts/hosts",fileTemp)

      fmt.Println("Downloading from pgl.yoyo.org :")
      download_and_copy("http://pgl.yoyo.org/adservers/serverlist.php?hostformat=hosts&showintro=0&mimetype=plaintext",fileTemp)
      fmt.Println("Downloading from downloads.sourceforge.net/project/adzhosts :")

      download_and_copy("http://downloads.sourceforge.net/project/adzhosts/FORADAWAY.txt",fileTemp)
      fmt.Println("Parsing, cleaning, de-duplicating, sorting...")
      remComL(fileTemp)
      usineAGaz(pathHosts, fileTemp)
      }
  } else {
    help()
  }
  var err = os.Remove(fileTemp)
  check(err)
}
